### Eclipse Workspace Patch 1.0
#P airplay-core
diff --git src/main/java/de/airsupply/airplay/core/importers/dbf/AirplayRecordMigrator.java src/main/java/de/airsupply/airplay/core/importers/dbf/AirplayRecordMigrator.java
index 8335fac..9eb43d1 100644
--- src/main/java/de/airsupply/airplay/core/importers/dbf/AirplayRecordMigrator.java
+++ src/main/java/de/airsupply/airplay/core/importers/dbf/AirplayRecordMigrator.java
@@ -90,10 +90,16 @@
 		for (Record record : records) {
 			String artistName = record.getStringValue("INTE").trim();
 			String songIdentifier = record.getStringValue("ARNR").trim();
 			String songName = record.getStringValue("TITL").trim();
 			String recordCompanyName = record.getStringValue("FIKU").trim();
+
+			// FIXME Publishers were not imported!!!
+			if (true) {
+				throw new IllegalArgumentException("Import Publishers, too");
+			}
+
 			String discIdentifier = record.getStringValue("PLNR").trim();
 
 			if (StringUtils.hasText(artistName) && StringUtils.hasText(songName)) {
 				Artist artist = context.getOrPersist(new Artist(artistName));
 				RecordCompany recordCompany = null;
#P airplay-web
diff --git src/main/java/de/airsupply/airplay/web/config/SafeObjectMapper.java src/main/java/de/airsupply/airplay/web/config/SafeObjectMapper.java
new file mode 100644
index 0000000..cec0f4b
--- /dev/null
+++ src/main/java/de/airsupply/airplay/web/config/SafeObjectMapper.java
@@ -0,0 +1,39 @@
+package de.airsupply.airplay.web.config;
+
+import com.fasterxml.jackson.core.SerializableString;
+import com.fasterxml.jackson.core.io.CharacterEscapes;
+import com.fasterxml.jackson.databind.ObjectMapper;
+
+@SuppressWarnings("serial")
+public class SafeObjectMapper extends ObjectMapper {
+
+	public class SafeCharacterEscapes extends CharacterEscapes {
+
+		private final int[] escapedCharacters;
+
+		public SafeCharacterEscapes() {
+			int[] escapedCharacters = CharacterEscapes.standardAsciiEscapesForJSON();
+			escapedCharacters['<'] = CharacterEscapes.ESCAPE_STANDARD;
+			escapedCharacters['>'] = CharacterEscapes.ESCAPE_STANDARD;
+			escapedCharacters['&'] = CharacterEscapes.ESCAPE_STANDARD;
+			escapedCharacters['\''] = CharacterEscapes.ESCAPE_STANDARD;
+			this.escapedCharacters = escapedCharacters;
+		}
+
+		@Override
+		public int[] getEscapeCodesForAscii() {
+			return escapedCharacters;
+		}
+
+		@Override
+		public SerializableString getEscapeSequence(int character) {
+			return null;
+		}
+
+	}
+
+	public SafeObjectMapper() {
+		this.getFactory().setCharacterEscapes(new SafeCharacterEscapes());
+	}
+
+}
diff --git src/main/webapp/css/angular-xeditable.css src/main/webapp/css/angular-xeditable.css
new file mode 100644
index 0000000..b90a1c4
--- /dev/null
+++ src/main/webapp/css/angular-xeditable.css
@@ -0,0 +1,7 @@
+/*!
+angular-xeditable - 0.1.7
+Edit-in-place for angular.js
+Build date: 2013-10-26 
+*/
+
+.editable-wrap{display:inline-block;white-space:nowrap;margin:0}.editable-wrap .editable-controls,.editable-wrap .editable-error{margin-bottom:0}.editable-wrap .editable-controls>input,.editable-wrap .editable-controls>select,.editable-wrap .editable-controls>textarea{margin-bottom:0}.editable-wrap .editable-input{display:inline-block}.editable-buttons{display:inline-block;vertical-align:top}.editable-buttons button{margin-left:5px}.editable-input.editable-has-buttons{width:auto}.editable-bstime .editable-input input[type=text]{width:46px}.editable-bstime .well-small{margin-bottom:0;padding:10px}.editable-range output{display:inline-block;min-width:30px;vertical-align:top;text-align:center}.editable-color input[type=color]{width:50px}.editable-hide{display:none!important}.editable-click,a.editable-click{text-decoration:none;color:#428bca;border-bottom:dashed 1px #428bca}.editable-click:hover,a.editable-click:hover{text-decoration:none;color:#2a6496;border-bottom-color:#2a6496}.editable-empty,.editable-empty:hover,.editable-empty:focus,a.editable-empty,a.editable-empty:hover,a.editable-empty:focus{font-style:italic;color:#D14;text-decoration:none}
\ No newline at end of file
diff --git src/main/webapp/index.html src/main/webapp/index.html
index 79bf908..ad1638d 100644
--- src/main/webapp/index.html
+++ src/main/webapp/index.html
@@ -2,18 +2,20 @@
 <html ng-app="airplay">
 <head>
 <meta charset="iso-8859-1">
 <title>AirPlay Manager</title>
 <link rel="stylesheet" href="./css/bootstrap.css">
+<link rel="stylesheet" href="./css/angular-xeditable.css">
 <link rel="stylesheet" href="./css/site.css">
 <script src="./js/lib/jquery.js"></script>
 <script src="./js/lib/jquery-ui.js"></script>
 <script src="./js/lib/bootstrap.js"></script>
 <script src="./js/lib/angular.js"></script>
 <script src="./js/lib/angular-resource.js"></script>
 <script src="./js/lib/angular-bootstrap-tpls.js"></script>
 <script src="./js/lib/angular-sortable.js"></script>
+<script src="./js/lib/angular-xeditable.js"></script>
 <script src="./js/commons/utils.js"></script>
 <script src="./js/commons/commons.js"></script>
 <script src="./js/modules.js"></script>
 <script src="./js/controllers.js"></script>
 </head>
diff --git src/main/webapp/js/commons/commons.js src/main/webapp/js/commons/commons.js
index 21fc6b0..da2e376 100644
--- src/main/webapp/js/commons/commons.js
+++ src/main/webapp/js/commons/commons.js
@@ -15,18 +15,22 @@
 		link : function(scope, element, attributes, controller) {
 			var errors = new Array();
 			scope.$on('asServerValidation', function(event, args) {
 				errors = args;
 				angular.forEach(errors, function(error) {
-					scope.form[error.field].$setValidity(error.code, false);
+					// scope.form[error.field].$setValidity(error.code, false);
+					scope.form.$setError(error.field, error.code);
 				});
 			});
 			controller.$parsers.unshift(function(viewValue) {
 				angular.forEach(errors, function(error) {
-					if (!angular.isUndefined(form[error.field])) {
-						scope.form[error.field].$setValidity(toFirstLower(error.code), true);
-					}
+					// if (!angular.isUndefined(form[error.field])) {
+					// scope.form[error.field].$setValidity(toFirstLower(error.code),
+					// true);
+
+					scope.form.$setError(error.field, error.code);
+					// }
 				});
 				errors = undefined;
 				return viewValue;
 			});
 		}
@@ -37,28 +41,26 @@
 	return {
 		apply : function(rejection, scope) {
 			var errors = new Array();
 			angular.forEach(rejection.data.errors, function(error) {
 				if (!angular.isUndefined(error.field)) {
-					if (!angular.isUndefined(form[error.field])) {
-						errors.push({
-							code : toFirstLower(error.code),
-							field : error.field
-						});
-					}
+					errors.push({
+						code : toFirstLower(error.code),
+						field : error.field
+					});
 				} else {
 					angular.forEach(error.arguments[1], function(field) {
-						if (!angular.isUndefined(form[field])) {
-							errors.push({
-								code : toFirstLower(error.code),
-								field : field
-							});
-						}
+						errors.push({
+							code : toFirstLower(error.code),
+							field : field
+						});
 					});
 				}
 			});
-			scope.$broadcast('asServerValidation', errors);
+			if (errors.length > 0) {
+				scope.$broadcast('asServerValidation', errors);
+			}
 			errors = undefined;
 		},
 	};
 });
 
@@ -107,11 +109,11 @@
 						return;
 					}
 					var result = remoteResource.find({
 						name : name
 					});
-					if (!promise) {
+					if (promise) {
 						return result.$then(function(response) {
 							return limitToFilter(response.data, limit);
 						});
 					} else {
 						return result;
diff --git src/main/webapp/js/commons/utils.js src/main/webapp/js/commons/utils.js
index 89e0e7a..8eaab13 100644
--- src/main/webapp/js/commons/utils.js
+++ src/main/webapp/js/commons/utils.js
@@ -27,27 +27,14 @@
 	} else {
 		from = ui.item.index();
 		to = ui.item.sortable.index + 1;
 	}
 	var items = undefined;
+	var index = from;
 	if (ui.item.sortable.resort) {
 		items = ui.item.sortable.resort.$viewValue.slice(from, to);
-	}
-	var indexInList = from;
-	var indexInSublist = 0;
-	return {
-		hasNext : function() {
-			if (!items) {
-				return false;
-			}
-			return indexInSublist < items.length;
-		},
-		next : function(callback) {
-			if (!items) {
-				return undefined;
-			}
-			callback.call(null, items[indexInSublist], indexInList);
-			indexInList = indexInList + 1;
-			indexInSublist = indexInSublist + 1;
+		for (var i = 0; i < items.length; ++i) {
+			callback.call(null, items[i], index);
+			index = index + 1;
 		}
-	};
+	}
 };
\ No newline at end of file
diff --git src/main/webapp/js/controllers.js src/main/webapp/js/controllers.js
index e1811cc..dc7f4e1 100644
--- src/main/webapp/js/controllers.js
+++ src/main/webapp/js/controllers.js
@@ -27,106 +27,54 @@
 			});
 		}
 	};
 	$scope.sortableOptions = {
 		stop : function(event, ui) {
-			var sorter = sort(ui);
-			while (sorter.hasNext()) {
-				var next = sorter.next(function(item, index) {
-					item.position = index + 1;
-				});
-			}
+			sort(ui, function(item, index) {
+				item.position = index + 1;
+			});
 		}
 	};
 } ]);
 
 application.controller('SongListController', [ '$scope', '$modal', '$timeout', 'ContentService', function($scope, $modal, $timeout, ContentService) {
 	$scope.results = 0;
 	$scope.findSongs = function(name) {
-		$scope.songs = ContentService.songs.search(name, null, true);
+		$scope.songs = ContentService.songs.search(name, null);
 	};
-	$scope.createItem = function() {
-		var modalInstance = $modal.open({
-			templateUrl : 'views/songs/detailTemplate.html',
-			controller : 'SongDetailController',
-			resolve : {
-				item : function() {
-					return null;
-				}
-			}
-		});
-		modalInstance.result.then(function(result) {
-			$scope.songs.push(result);
-			createAlert("Song: " + result.name + " has been created!", "success", $scope, $timeout);
-		}, function() {
-			createAlert("Song has not been created!", "warning", $scope, $timeout);
-		});
-	};
-	$scope.deleteItem = function(song) {
-		song.$delete(function() {
-			$scope.songs.splice($scope.songs.indexOf(song), 1);
-		});
-	};
-	$scope.editItem = function(item) {
-		var modalInstance = $modal.open({
-			templateUrl : 'views/songs/detailTemplate.html',
-			controller : 'SongDetailController',
-			resolve : {
-				item : function() {
-					return item;
-				}
-			}
-		});
-		modalInstance.result.then(function(result) {
-			angular.extend(item, result);
-			createAlert("Song: " + result.name + " has been saved!", "success", $scope, $timeout);
-		}, function() {
-			createAlert("Song: " + item.name + " has not been saved!", "warning", $scope, $timeout);
-		});
-	};
-} ]);
-
-application.controller('SongDetailController', [ '$scope', '$modalInstance', 'ContentService', 'item', function($scope, $modalInstance, ContentService, item) {
-	var create = item == null;
-	$scope.create = create;
-	$scope.edit = !create;
-	if (!create) {
-		$scope.song = angular.copy(item);
-		$scope.master = angular.copy($scope.song);
-	} else {
-		$scope.song = {};
-	}
 	$scope.artists = function(name) {
-		return ContentService.artists.search(name, 10);
+		return ContentService.artists.search(name, 10, true);
 	};
 	$scope.publishers = function(name) {
-		return ContentService.publishers.search(name, 10);
+		return ContentService.publishers.search(name, 10, true);
 	};
 	$scope.recordCompanies = function(name) {
-		return ContentService.recordCompanies.search(name, 10);
+		return ContentService.recordCompanies.search(name, 10, true);
 	};
-	$scope.save = function() {
-		if (!create) {
-			ContentService.songs.resource().put({
-				identifier : $scope.song.identifier,
-			}, $scope.song, function() {
-				$modalInstance.close($scope.song);
+	$scope.createItem = function() {
+		$scope.inserted = {
+			name : '',
+		};
+		$scope.songs.push($scope.inserted);
+	};
+	$scope.deleteItem = function(item) {
+		song.$delete(function() {
+			$scope.songs.splice($scope.songs.indexOf(item), 1);
+		});
+	};
+	$scope.saveItem = function(item, identifier) {
+		angular.extend(item, {
+			identifier : identifier
+		});
+		if (item.identifier) {
+			return ContentService.songs.resource().put({
+				identifier : item.identifier,
+			}, item).$then(function(response) {
+				return response;
 			});
 		} else {
-			ContentService.songs.resource().post({}, $scope.song, function() {
-				$modalInstance.close($scope.song);
-			});
+			return ContentService.songs.resource().post({}, item);
 		}
+		// createAlert("Song: " + item.name + " has been saved!", "success",
+		// $scope, $timeout);
 	};
-	$scope.cancel = function() {
-		$scope.reset();
-		$modalInstance.dismiss();
-	};
-	$scope.reset = function() {
-		if (!create) {
-			angular.extend($scope.song, $scope.master);
-		}
-	};
-	$scope.unchanged = function() {
-		return !create && angular.equals($scope.song, $scope.master);
-	};
-} ]);
+} ]);
\ No newline at end of file
diff --git src/main/webapp/js/lib/angular-xeditable.js src/main/webapp/js/lib/angular-xeditable.js
new file mode 100644
index 0000000..2798c1f
--- /dev/null
+++ src/main/webapp/js/lib/angular-xeditable.js
@@ -0,0 +1,1387 @@
+/*!
+angular-xeditable - 0.1.7
+Edit-in-place for angular.js
+Build date: 2013-10-26 
+*/
+/*
+angular-xeditable module
+*/
+angular.module('xeditable', [])
+.value('editableOptions', {
+  theme: 'default', //bs2, bs3,
+  buttons: 'right',
+  blur: 'cancel'
+});
+
+
+/*
+Angular-ui bootstrap datepicker
+http://angular-ui.github.io/bootstrap/#/datepicker
+*/
+angular.module('xeditable').directive('editableBsdate', ['editableDirectiveFactory',
+  function(editableDirectiveFactory) {
+    return editableDirectiveFactory({
+      directiveName: 'editableBsdate',
+      inputTpl: '<input type="text">'
+    });
+}]);
+/*
+Angular-ui bootstrap editable timepicker
+http://angular-ui.github.io/bootstrap/#/timepicker
+*/
+angular.module('xeditable').directive('editableBstime', ['editableDirectiveFactory',
+  function(editableDirectiveFactory) {
+    return editableDirectiveFactory({
+      directiveName: 'editableBstime',
+      inputTpl: '<timepicker></timepicker>',
+      render: function() {
+        this.parent.render.call(this);
+
+        // timepicker can't update model when ng-model set directly to it
+        // see: https://github.com/angular-ui/bootstrap/issues/1141
+        // so we wrap it into DIV
+        var div = angular.element('<div class="well well-small" style="display:inline-block;"></div>');
+
+        // move ng-model to wrapping div
+        div.attr('ng-model', this.inputEl.attr('ng-model'));
+        this.inputEl.removeAttr('ng-model');
+
+        // move ng-change to wrapping div
+        if(this.attrs.eNgChange) {
+          div.attr('ng-change', this.inputEl.attr('ng-change'));
+          this.inputEl.removeAttr('ng-change');
+        }
+
+        // wrap
+        this.inputEl.wrap(div);
+      }
+    });
+}]);
+//checkbox
+angular.module('xeditable').directive('editableCheckbox', ['editableDirectiveFactory',
+  function(editableDirectiveFactory) {
+    return editableDirectiveFactory({
+      directiveName: 'editableCheckbox',
+      inputTpl: '<input type="checkbox">',
+      render: function() {
+        this.parent.render.call(this);
+        if(this.attrs.eTitle) {
+          this.inputEl.wrap('<label></label>');
+          this.inputEl.after(angular.element('<span></span>').text(' '+this.attrs.eTitle));
+        }
+      },
+      autosubmit: function() {
+        var self = this;
+        self.inputEl.bind('change', function() {
+          setTimeout(function() {
+            self.scope.$apply(function() {
+              self.scope.$form.$submit();
+            });
+          }, 500);
+        });
+      }
+    });
+}]);
+/*
+Input types: text|email|tel|number|url|search|color|date|datetime|time|month|week
+*/
+
+(function() {
+
+  var types = 'text|email|tel|number|url|search|color|date|datetime|time|month|week'.split('|');
+
+  //todo: datalist
+  
+  // generate directives
+  angular.forEach(types, function(type) {
+    var directiveName = 'editable'+type.charAt(0).toUpperCase() + type.slice(1);
+    angular.module('xeditable').directive(directiveName, ['editableDirectiveFactory',
+      function(editableDirectiveFactory) {
+        return editableDirectiveFactory({
+          directiveName: directiveName,
+          inputTpl: '<input type="'+type+'">'
+        });
+    }]);
+  });
+
+  //`range` is bit specific
+  angular.module('xeditable').directive('editableRange', ['editableDirectiveFactory',
+    function(editableDirectiveFactory) {
+      return editableDirectiveFactory({
+        directiveName: 'editableRange',
+        inputTpl: '<input type="range" id="range" name="range">',
+        render: function() {
+          this.parent.render.call(this);
+          this.inputEl.after('<output>{{$data}}</output>');
+        }        
+      });
+  }]);
+
+}());
+
+
+//select
+angular.module('xeditable').directive('editableSelect', ['editableDirectiveFactory',
+  function(editableDirectiveFactory) {
+    return editableDirectiveFactory({
+      directiveName: 'editableSelect',
+      inputTpl: '<select></select>',
+      autosubmit: function() {
+        var self = this;
+        self.inputEl.bind('change', function() {
+          self.scope.$apply(function() {
+            self.scope.$form.$submit();
+          });
+        });
+      }
+    });
+}]);
+//textarea
+angular.module('xeditable').directive('editableTextarea', ['editableDirectiveFactory',
+  function(editableDirectiveFactory) {
+    return editableDirectiveFactory({
+      directiveName: 'editableTextarea',
+      inputTpl: '<textarea></textarea>',
+      addListeners: function() {
+        var self = this;
+        self.parent.addListeners.call(self);
+        // submit textarea by ctrl+enter even with buttons
+        if (self.single && self.buttons !== 'no') {
+          self.autosubmit();
+        }
+      },
+      autosubmit: function() {
+        var self = this;
+        self.inputEl.bind('keydown', function(e) {
+          if ((e.ctrlKey || e.metaKey) && (e.keyCode === 13)) {
+            self.scope.$apply(function() {
+              self.scope.$form.$submit();
+            });
+          }
+        });
+      }
+    });
+}]);
+
+/**
+ * EditableController class. 
+ * Attached to element with `editable-xxx` directive.
+ *
+ * @namespace editable-element
+ */
+/*
+TODO: this file should be refactored to work more clear without closures!
+*/
+angular.module('xeditable').factory('editableController', ['$q', '$document', 'editableUtils', '$rootScope',
+  function($q, $document, utils, $rootScope) {
+
+  // array of opened editable controls
+  var shown = [];
+
+  // bind click to body: cancel|submit editables
+  $document.bind('click', function(e) {
+    // ignore right/middle button click
+    if (e.which !== 1) {
+      return;
+    }
+
+    var toCancel = [];
+    var toSubmit = [];
+    for (var i=0; i<shown.length; i++) {
+      // exclude self
+      if (shown[i].clicked) {
+        shown[i].clicked = false;
+        continue;
+      }
+
+      if (shown[i].blur === 'cancel') {
+        toCancel.push(shown[i]);
+      }
+      if (shown[i].blur === 'submit') {
+        toSubmit.push(shown[i]);
+      }
+    }
+
+    if (toCancel.length || toSubmit.length) {
+      $rootScope.$apply(function() {
+        angular.forEach(toCancel, function(v){ v.scope.$form.$hide(); });
+        angular.forEach(toSubmit, function(v){ v.scope.$form.$submit(); });
+      });
+    }
+  });
+
+  //EditableController function
+  EditableController.$inject = ['$scope', '$attrs', '$element', '$parse', 'editableThemes', 'editableOptions', '$rootScope', '$compile', '$q'];
+  function EditableController($scope, $attrs, $element, $parse, editableThemes, editableOptions, $rootScope, $compile, $q) {
+    var valueGetter;
+
+    //if control is disabled - it does not participate in waiting process
+    var inWaiting;
+
+    var self = this;
+
+    self.scope = $scope;
+    self.elem = $element;
+    self.attrs = $attrs;
+    self.inputEl = null;
+    self.editorEl = null;
+    self.single = true;
+    self.error = '';
+    self.theme =  editableThemes[editableOptions.theme] || editableThemes['default'];
+    self.parent = {};
+    self.clicked = false; //used to check in document click handler if control was clicked or not
+
+    //to be overwritten by directive
+    self.inputTpl = '';
+    self.directiveName = '';
+
+    //runtime (defaults)
+    self.single = null;
+
+    /**
+     * Attributes defined with `e-*` prefix automatically transfered from original element to
+     * control.  
+     * For example, if you set `<span editable-text="user.name" e-style="width: 100px"`>
+     * then input will appear as `<input style="width: 100px">`.  
+     * See [demo](#text-customize).
+     * 
+     * @var {any|attribute} e-*
+     * @memberOf editable-element
+     */ 
+
+    /**
+     * Whether to show ok/cancel buttons. Values: `right|no`.
+     * If set to `no` control automatically submitted when value changed.  
+     * If control is part of form buttons will never be shown. 
+     * 
+     * @var {string|attribute} buttons
+     * @memberOf editable-element
+     */    
+    self.buttons = 'right'; 
+    /**
+     * Action when control losses focus. Values: `cancel|submit|ignore`.
+     * If control is part of form `blur` automatically set to `ignore`.  
+     * 
+     * @var {string|attribute} blur
+     * @memberOf editable-element
+     */     
+    self.blur = 'ignore'; // can be 'cancel|submit|ignore'
+
+    //init
+    self.init = function(single) {
+      self.single = single;
+
+      self.name = $attrs.eName || $attrs[self.directiveName];
+      /*
+      if(!$attrs[directiveName] && !$attrs.eNgModel && ($attrs.eValue === undefined)) {
+        throw 'You should provide value for `'+directiveName+'` or `e-value` in editable element!';
+      }
+      */
+      if($attrs[self.directiveName]) {
+        valueGetter = $parse($attrs[self.directiveName]);
+      } else {
+        throw 'You should provide value for `'+self.directiveName+'` in editable element!';
+      }
+
+      // settings for single and non-single
+      if (!self.single) {
+        // hide buttons for non-single
+        self.buttons = 'no';
+        self.blur = 'ignore';
+      } else {
+        self.buttons = self.attrs.buttons || editableOptions.buttons;
+        self.blur = self.attrs.blur || (self.buttons === 'no' ? 'cancel' : editableOptions.blur);
+      }
+
+      //moved to show()
+      //self.render();
+
+      //if name defined --> watch changes and update $data in form
+      if($attrs.eName) {
+        self.scope.$watch('$data', function(newVal){
+          self.scope.$form.$data[$attrs.eName] = newVal;
+        });
+      }
+
+      /**
+       * Called when control is shown.  
+       * See [demo](#select-remote).
+       * 
+       * @var {method|attribute} onshow
+       * @memberOf editable-element
+       */
+      if($attrs.onshow) {
+        self.onshow = function() {
+          return self.catchError($parse($attrs.onshow)($scope));
+        };
+      }
+
+      /**
+       * Called when control is hidden after both save or cancel.  
+       * 
+       * @var {method|attribute} onhide
+       * @memberOf editable-element
+       */
+      if($attrs.onhide) {
+        self.onhide = function() {
+          return $parse($attrs.onhide)($scope);
+        };
+      }
+
+      /**
+       * Called when control is cancelled.  
+       * 
+       * @var {method|attribute} oncancel
+       * @memberOf editable-element
+       */
+      if($attrs.oncancel) {
+        self.oncancel = function() {
+          return $parse($attrs.oncancel)($scope);
+        };
+      }          
+
+      /**
+       * Called during submit before value is saved to model.  
+       * See [demo](#onbeforesave).
+       * 
+       * @var {method|attribute} onbeforesave
+       * @memberOf editable-element
+       */
+      if ($attrs.onbeforesave) {
+        self.onbeforesave = function() {
+          return self.catchError($parse($attrs.onbeforesave)($scope));
+        };
+      }
+
+      /**
+       * Called during submit after value is saved to model.  
+       * See [demo](#onaftersave).
+       * 
+       * @var {method|attribute} onaftersave
+       * @memberOf editable-element
+       */
+      if ($attrs.onaftersave) {
+        self.onaftersave = function() {
+          return self.catchError($parse($attrs.onaftersave)($scope));
+        };
+      }
+
+      // watch change of model to update editable element
+      // now only add/remove `editable-empty` class.
+      // Initially this method called with newVal = undefined, oldVal = undefined
+      // so no need initially call handleEmpty() explicitly
+      $scope.$parent.$watch($attrs[self.directiveName], function(newVal, oldVal) {
+        self.handleEmpty();
+      });
+    };
+
+    self.render = function() {
+      var theme = self.theme;
+
+      //build input
+      self.inputEl = angular.element(self.inputTpl);
+
+      //build controls
+      self.controlsEl = angular.element(theme.controlsTpl);
+      self.controlsEl.append(self.inputEl);
+
+      //build buttons
+      if(self.buttons !== 'no') {
+        self.buttonsEl = angular.element(theme.buttonsTpl);
+        self.submitEl = angular.element(theme.submitTpl);
+        self.cancelEl = angular.element(theme.cancelTpl);
+        self.buttonsEl.append(self.submitEl).append(self.cancelEl);
+        self.controlsEl.append(self.buttonsEl);
+        
+        self.inputEl.addClass('editable-has-buttons');
+      }
+
+      //build error
+      self.errorEl = angular.element(theme.errorTpl);
+      self.controlsEl.append(self.errorEl);
+
+      //build editor
+      self.editorEl = angular.element(self.single ? theme.formTpl : theme.noformTpl);
+      self.editorEl.append(self.controlsEl);
+
+      // transfer `e-*|data-e-*|x-e-*` attributes
+      for(var k in $attrs.$attr) {
+        if(k.length <= 1) {
+          continue;
+        }
+        var transferAttr = false;
+        var nextLetter = k.substring(1, 2);
+
+        // if starts with `e` + uppercase letter
+        if(k.substring(0, 1) === 'e' && nextLetter === nextLetter.toUpperCase()) {
+          transferAttr = k.substring(1); // cut `e`
+        } else {
+          continue;
+        }
+        
+        // exclude `form` and `ng-submit`, 
+        if(transferAttr === 'Form' || transferAttr === 'NgSubmit') {
+          continue;
+        }
+
+        // convert back to lowercase style
+        transferAttr = transferAttr.substring(0, 1).toLowerCase() + utils.camelToDash(transferAttr.substring(1));  
+
+        // workaround for attributes without value (e.g. `multiple = "multiple"`)
+        var attrValue = ($attrs[k] === '') ? transferAttr : $attrs[k];
+
+        // set attributes to input
+        self.inputEl.attr(transferAttr, attrValue);
+      }
+
+      self.inputEl.addClass('editable-input');
+      self.inputEl.attr('ng-model', '$data');
+
+      // add directiveName class to editor, e.g. `editable-text`
+      self.editorEl.addClass(utils.camelToDash(self.directiveName));
+
+      if(self.single) {
+        self.editorEl.attr('editable-form', '$form');
+      }
+
+      //apply `postrender` method of theme
+      if(angular.isFunction(theme.postrender)) {
+        theme.postrender.call(self);
+      }
+
+    };
+
+    //show
+    self.show = function() {
+      // set value. copy not needed.
+      // self.scope.$data = angular.copy(valueGetter($scope.$parent));
+      self.scope.$data = valueGetter($scope.$parent);
+
+      /*
+      Originally render() was inside init() method, but some directives polluting editorEl,
+      so it is broken on second openning.
+      Cloning is not a solution as jqLite can not clone with event handler's.
+      */
+      self.render();
+
+      // insert into DOM
+      $element.after(self.editorEl);
+
+      // compile (needed to attach ng-* events from markup)
+      $compile(self.editorEl)($scope);
+
+      // attach listeners (`escape`, autosubmit, etc)
+      self.addListeners();
+
+      // hide element
+      $element.addClass('editable-hide');
+
+      // add to internal list
+      // setTimeout needed to prevent closing right after opening (e.g. when trigger by button)
+      setTimeout(function() {
+        if(utils.indexOf(shown, self) === -1) {
+          shown.push(self);
+        }
+      }, 0);
+
+      // onshow
+      return self.onshow();
+    };
+
+    //hide
+    self.hide = function() {
+      //console.log('editable hide', self.name);
+      self.editorEl.remove();
+      $element.removeClass('editable-hide');
+
+      // remove from internal list
+      utils.arrayRemove(shown, self);
+
+      // onhide
+      return self.onhide();
+
+      // todo: to think is it really needed or not
+      /*
+      if($element[0].tagName === 'A') {
+        $element[0].focus();
+      }
+      */
+    };
+
+    // cancel
+    self.cancel = function() {
+      // oncancel
+      self.oncancel();
+      // don't call hide() here as it called in form's code
+    };
+
+    /*
+    Called after show to attach listeners
+    */
+    self.addListeners = function() {
+      // bind keyup for `escape`
+      self.inputEl.bind('keyup', function(e) {
+          if(!self.single) {
+            return;
+          }
+
+          switch(e.keyCode) {
+            // hide on `escape` press
+            case 27:
+              self.scope.$form.$cancel();
+            break;
+          }
+      });
+
+      // autosubmit when `no buttons`
+      if (self.single && self.buttons === 'no') {
+        self.autosubmit();
+      }
+
+      // click - mark element as clicked to exclude in document click handler
+      self.editorEl.bind('click', function(e) {
+        // ignore right/middle button click
+        if (e.which !== 1) {
+          return;
+        }
+
+        self.clicked = true;
+      });
+    };
+
+    // setWaiting
+    self.setWaiting = function(value) {
+      if (value) {
+        //participate in waiting only if not disabled
+        inWaiting = !self.inputEl.attr('disabled') &&
+                    !self.inputEl.attr('ng-disabled') &&
+                    !self.inputEl.attr('ng-enabled');
+        if (inWaiting) {
+          self.inputEl.attr('disabled', 'disabled');
+          if(self.buttonsEl) {
+            self.buttonsEl.find('button').attr('disabled', 'disabled');
+          }
+        }
+      } else {
+        if (inWaiting) {
+          self.inputEl.removeAttr('disabled');
+          if (self.buttonsEl) {
+            self.buttonsEl.find('button').removeAttr('disabled');
+          }
+        }
+      }
+    };
+
+    self.activate = function() {
+      setTimeout(function() {
+        self.inputEl[0].focus();
+      }, 0);
+    };
+
+    self.setError = function(msg) {
+      if(!angular.isObject(msg)) {
+        $scope.$error = msg;
+        self.error = msg;
+      }
+    };
+
+    /*
+    Checks that result is string or promise returned string and shows it as error message
+    Applied to onshow, onbeforesave, onaftersave
+    */
+    self.catchError = function(result, noPromise) {
+      if (angular.isObject(result) && noPromise !== true) {
+        $q.when(result).then(
+          //success and fail handlers are equal
+          angular.bind(this, function(r) {
+            this.catchError(r, true);
+          }),
+          angular.bind(this, function(r) {
+            this.catchError(r, true);
+          })
+        );
+      //check $http error
+      } else if (noPromise && angular.isObject(result) && result.status &&
+        (result.status !== 200) && result.data && angular.isString(result.data)) {
+        this.setError(result.data);
+        //set result to string: to let form know that there was error
+        result = result.data;
+      } else if (angular.isString(result)) {
+        this.setError(result);
+      }
+      return result;
+    };
+
+    self.save = function() {
+      valueGetter.assign($scope.$parent, angular.copy(self.scope.$data));
+
+      // no need to call handleEmpty here as we are watching change of model value
+      // self.handleEmpty();
+    };
+
+    /*
+    attach/detach `editable-empty` class to element
+    */
+    self.handleEmpty = function() {
+      var val = valueGetter($scope.$parent);
+      var isEmpty = val === null || val === undefined || val === "" || (angular.isArray(val) && val.length === 0); 
+      $element.toggleClass('editable-empty', isEmpty);
+    };
+
+    /*
+    Called when `buttons = "no"` to submit automatically
+    */
+    self.autosubmit = angular.noop;
+
+    self.onshow = angular.noop;
+    self.onhide = angular.noop;
+    self.oncancel = angular.noop;
+    self.onbeforesave = angular.noop;
+    self.onaftersave = angular.noop;
+  }
+
+  return EditableController;
+}]);
+
+/*
+editableFactory:
+- attaches editableController to element
+- used to generate editable directives
+
+Depends on: editableController, editableFormFactory
+*/
+angular.module('xeditable').factory('editableDirectiveFactory',
+['$parse', '$compile', 'editableThemes', '$rootScope', '$document', 'editableController', 'editableFormController',
+function($parse, $compile, editableThemes, $rootScope, $document, editableController, editableFormController) {
+
+  //directive object
+  return function(overwrites) {
+    return {
+      restrict: 'A',
+      scope: true,
+      require: [overwrites.directiveName, '?^form'],
+      controller: editableController,
+      link: function(scope, elem, attrs, ctrl) {
+        //editable controller
+        var eCtrl = ctrl[0];
+
+        //form controller
+        var eFormCtrl;
+        var hasForm = false;
+
+        //if not inside form, but we have `e-form`:
+        //check if form exists somewhere in scope. If exists - bind, otherwise create.
+        if(ctrl[1]) {
+          eFormCtrl = ctrl[1];
+          hasForm = true;
+        } else if(attrs.eForm) {
+          var getter = $parse(attrs.eForm)(scope);
+          if(getter) { //getter defined, form above
+            eFormCtrl = getter;
+            hasForm = true;
+          } else { //form below or not exist: check document.forms
+            for(var i=0; i<$document[0].forms.length;i++){
+              if($document[0].forms[i].name === attrs.eForm) {
+                //form is below and not processed yet
+                eFormCtrl = null;
+                hasForm = true;
+                break;
+              }
+            }
+          }
+        }
+
+        /*
+        if(hasForm && !attrs.eName) {
+          throw 'You should provide `e-name` for editable element inside form!';
+        }
+        */
+
+        //check for `editable-form` attr in form
+        /*
+        if(eFormCtrl && ) {
+          throw 'You should provide `e-name` for editable element inside form!';
+        }
+        */
+
+        //store original props to `parent` before merge
+        angular.forEach(overwrites, function(v, k) {
+          if(eCtrl[k] !== undefined) {
+            eCtrl.parent[k] = eCtrl[k];
+          }
+        });
+
+        //merge overwrites to base editable controller
+        angular.extend(eCtrl, overwrites);
+
+        //init editable ctrl
+        eCtrl.init(!hasForm);
+
+        //publich editable controller as `$editable` to be referenced in html
+        scope.$editable = eCtrl;
+
+        // add `editable` class to element
+        elem.addClass('editable');
+
+        // hasForm
+        if(hasForm) {
+          if(eFormCtrl) {
+            scope.$form = eFormCtrl;
+            if(!scope.$form.$addEditable) {
+              throw 'Form with editable elements should have `editable-form` attribute.';
+            }
+            scope.$form.$addEditable(eCtrl);
+          } else {
+            // future form (below): add editable controller to buffer and add to form later
+            $rootScope.$$editableBuffer = $rootScope.$$editableBuffer || {};
+            $rootScope.$$editableBuffer[attrs.eForm] = $rootScope.$$editableBuffer[attrs.eForm] || [];
+            $rootScope.$$editableBuffer[attrs.eForm].push(eCtrl);
+            scope.$form = null; //will be re-assigned later
+          }
+        // !hasForm
+        } else {
+
+          //create editableform controller
+          scope.$form = editableFormController();
+          //add self to editable controller
+          scope.$form.$addEditable(eCtrl);
+
+          //elem.after(self.editorEl);
+        //console.log('w:', scope.$$watchers.length);
+          //$compile(eCtrl.editorEl)(scope);
+          //scope.$form.$addEditable(eCtrl);
+        //console.log('w:', scope.$$watchers.length);
+          //eCtrl.editorEl.remove();
+
+          //if `e-form` provided, publish local $form in scope
+          if(attrs.eForm) {
+            scope.$parent[attrs.eForm] = scope.$form;
+          }
+
+          //bind click - if no external form defined
+          if(!attrs.eForm) {
+            elem.addClass('editable-click');
+            elem.bind('click', function(e) {
+              e.preventDefault();
+              e.editable = eCtrl;
+              scope.$apply(function(){
+                scope.$form.$show();
+              });
+            });
+          }
+        }
+
+      }
+    };
+  };
+}]);
+
+/*
+Returns editableForm controller
+*/
+angular.module('xeditable').factory('editableFormController', 
+  ['$parse', 'editablePromiseCollection',
+  function($parse, editablePromiseCollection) {
+
+  var base = {
+    $addEditable: function(editable) {
+      //console.log('add editable', editable.elem, editable.elem.bind);
+      this.$editables.push(editable);
+
+      //'on' is not supported in angular 1.0.8
+      editable.elem.bind('$destroy', angular.bind(this, this.$removeEditable, editable));
+
+      //bind editable's local $form to self (if not bound yet, below form) 
+      if (!editable.scope.$form) {
+        editable.scope.$form = this;
+      }
+
+      //if form already shown - call show() of new editable
+      if (this.$visible) {
+        editable.catchError(editable.show());
+      }
+    },
+
+    $removeEditable: function(editable) {
+      //arrayRemove
+      for(var i=0; i < this.$editables.length; i++) {
+        if(this.$editables[i] === editable) {
+          this.$editables.splice(i, 1);
+          return;
+        }
+      }
+    },
+
+    /**
+     * Shows form with editable controls.
+     * 
+     * @method $show()
+     * @memberOf editable-form
+     */
+    $show: function() {
+      if (this.$visible) {
+        return;
+      }
+
+      this.$visible = true;
+
+      var pc = editablePromiseCollection();
+
+      //own show
+      pc.when(this.$onshow());
+
+      //clear errors
+      this.$setError(null, '');
+
+      //children show
+      angular.forEach(this.$editables, function(editable) {
+        pc.when(editable.show());
+      });
+
+      //wait promises and activate
+      pc.then({
+        onWait: angular.bind(this, this.$setWaiting), 
+        onTrue: angular.bind(this, this.$activate), 
+        onFalse: angular.bind(this, this.$activate), 
+        onString: angular.bind(this, this.$activate)
+      });
+    },
+
+    /**
+     * Sets focus on form field specified by `name`.
+     * 
+     * @method $activate(name)
+     * @param {string} name name of field
+     * @memberOf editable-form
+     */
+    $activate: function(name) {
+      var i;
+      if (this.$editables.length) {
+        //activate by name
+        if (angular.isString(name)) {
+          for(i=0; i<this.$editables.length; i++) {
+            if (this.$editables[i].name === name) {
+              this.$editables[i].activate();
+              return;
+            }
+          }
+        }
+
+        //try activate error field
+        for(i=0; i<this.$editables.length; i++) {
+          if (this.$editables[i].error) {
+            this.$editables[i].activate();
+            return;
+          }
+        }
+
+        //by default activate first field
+        this.$editables[0].activate();
+      }
+    },
+
+    /**
+     * Hides form with editable controls without saving.
+     * 
+     * @method $hide()
+     * @memberOf editable-form
+     */
+    $hide: function() {
+      if (!this.$visible) {
+        return;
+      }      
+      this.$visible = false;
+      // self hide
+      this.$onhide();
+      // children's hide
+      angular.forEach(this.$editables, function(editable) {
+        editable.hide();
+      });
+    },
+
+    /**
+     * Triggers `oncancel` event and calls `$hide()`.
+     * 
+     * @method $cancel()
+     * @memberOf editable-form
+     */
+    $cancel: function() {
+      if (!this.$visible) {
+        return;
+      }      
+      // self cancel
+      this.$oncancel();
+      // children's cancel      
+      angular.forEach(this.$editables, function(editable) {
+        editable.cancel();
+      });
+      // self hide
+      this.$hide();
+    },    
+
+    $setWaiting: function(value) {
+      this.$waiting = !!value;
+      // we can't just set $waiting variable and use it via ng-disabled in children
+      // because in editable-row form is not accessible
+      angular.forEach(this.$editables, function(editable) {
+        editable.setWaiting(!!value);
+      });
+    },
+
+    /**
+     * Shows error message for particular field.
+     * 
+     * @method $setError(name, msg)
+     * @param {string} name name of field
+     * @param {string} msg error message
+     * @memberOf editable-form
+     */
+    $setError: function(name, msg) {
+      angular.forEach(this.$editables, function(editable) {
+    	  if(!name || editable.name === name) {
+          editable.setError(msg);
+        }
+      });
+    },
+
+    $submit: function() {
+      if (this.$waiting) {
+        return;
+      } 
+
+      //clear errors
+      this.$setError(null, '');
+
+      //children onbeforesave
+      var pc = editablePromiseCollection();
+      angular.forEach(this.$editables, function(editable) {
+        pc.when(editable.onbeforesave());
+      });
+
+      /*
+      onbeforesave result:
+      - true/undefined: save data and close form
+      - false: close form without saving
+      - string: keep form open and show error
+      */
+      pc.then({
+        onWait: angular.bind(this, this.$setWaiting), 
+        onTrue: angular.bind(this, checkSelf, true), 
+        onFalse: angular.bind(this, checkSelf, false), 
+        onString: angular.bind(this, this.$activate)
+      });
+
+      //save
+      function checkSelf(childrenTrue){
+        var pc = editablePromiseCollection();
+        pc.when(this.$onbeforesave());
+        pc.then({
+          onWait: angular.bind(this, this.$setWaiting), 
+          onTrue: childrenTrue ? angular.bind(this, this.$save) : angular.bind(this, this.$hide), 
+          onFalse: angular.bind(this, this.$hide), 
+          onString: angular.bind(this, this.$activate)
+        });
+      }
+    },
+
+    $save: function() {
+      // write model for each editable
+      angular.forEach(this.$editables, function(editable) {
+        editable.save();
+      });
+
+      //call onaftersave of self and children
+      var pc = editablePromiseCollection();
+      pc.when(this.$onaftersave());
+      angular.forEach(this.$editables, function(editable) {
+        pc.when(editable.onaftersave());
+      });
+
+      /*
+      onaftersave result:
+      - true/undefined/false: just close form
+      - string: keep form open and show error
+      */
+      pc.then({
+        onWait: angular.bind(this, this.$setWaiting), 
+        onTrue: angular.bind(this, this.$hide), 
+        onFalse: angular.bind(this, this.$hide), 
+        onString: angular.bind(this, this.$activate)
+      });
+    },
+
+    $onshow: angular.noop,
+    $oncancel: angular.noop,
+    $onhide: angular.noop,
+    $onbeforesave: angular.noop,
+    $onaftersave: angular.noop
+  };
+
+  return function() {
+    return angular.extend({
+      $editables: [],
+      /**
+       * Form visibility flag.
+       * 
+       * @var {bool} $visible
+       * @memberOf editable-form
+       */
+      $visible: false,
+      /**
+       * Form waiting flag. It becomes `true` when form is loading or saving data.
+       * 
+       * @var {bool} $waiting
+       * @memberOf editable-form
+       */
+      $waiting: false,
+      $data: {}
+    }, base);
+  };
+}]);
+
+/**
+ * EditableForm directive. Should be defined in <form> containing editable controls.  
+ * It add some usefull methods to form variable exposed to scope by `name="myform"` attribute.
+ *
+ * @namespace editable-form
+ */
+angular.module('xeditable').directive('editableForm',
+  ['$rootScope', '$parse', 'editableFormController',
+  function($rootScope, $parse, editableFormController) {
+    return {
+      restrict: 'A',
+      require: ['form'],
+      //require: ['form', 'editableForm'],
+      //controller: EditableFormController,
+      compile: function() {
+        return {
+          pre: function(scope, elem, attrs, ctrl) {
+            var form = ctrl[0];
+            var eForm;
+
+            /*
+            Maybe it's better attach editable controller to form's controller not in pre()
+            but in controller itself. 
+            This allows to use ng-init already in <form> tag, otherwise we can't (in FF).
+            */
+
+            //if `editableForm` has value - publish smartly under this value
+            //this is required only for single editor form that is created and removed
+            if(attrs.editableForm) {
+              if(scope[attrs.editableForm] && scope[attrs.editableForm].$show) {
+                eForm = scope[attrs.editableForm];
+                angular.extend(form, eForm);
+              } else {
+                eForm = editableFormController();
+                scope[attrs.editableForm] = eForm;
+                angular.extend(eForm, form);
+              }
+            } else { //just merge to form and publish if form has name
+              eForm = editableFormController();
+              angular.extend(form, eForm);
+            }
+
+            //read editables from buffer (that appeared before FORM tag)
+            var buf = $rootScope.$$editableBuffer;
+            var name = form.$name;
+            if(name && buf && buf[name]) {
+              angular.forEach(buf[name], function(editable) {
+                eForm.$addEditable(editable);
+              });
+              delete buf[name];
+            }
+          },
+          post: function(scope, elem, attrs, ctrl) {
+            var eForm;
+
+            if(attrs.editableForm && scope[attrs.editableForm] && scope[attrs.editableForm].$show) {
+              eForm = scope[attrs.editableForm];
+            } else {
+              eForm = ctrl[0];
+            }
+
+            /**
+             * Called when form is shown.
+             * 
+             * @var {method|attribute} onshow 
+             * @memberOf editable-form
+             */
+            if(attrs.onshow) {
+              eForm.$onshow = angular.bind(eForm, $parse(attrs.onshow), scope);
+            }
+
+            /**
+             * Called when form hides after both save or cancel.
+             * 
+             * @var {method|attribute} onhide 
+             * @memberOf editable-form
+             */
+            if(attrs.onhide) {
+              eForm.$onhide = angular.bind(eForm, $parse(attrs.onhide), scope);
+            }
+
+            /**
+             * Called when form is cancelled.
+             * 
+             * @var {method|attribute} oncancel
+             * @memberOf editable-form
+             */
+            if(attrs.oncancel) {
+              eForm.$oncancel = angular.bind(eForm, $parse(attrs.oncancel), scope);
+            }
+
+            /**
+             * Whether form initially rendered in shown state.
+             *
+             * @var {bool|attribute} shown
+             * @memberOf editable-form
+             */
+            if(attrs.shown && $parse(attrs.shown)(scope)) {
+              eForm.$show();
+            }
+
+            // onbeforesave, onaftersave
+            if(!attrs.ngSubmit && !attrs.submit) {
+              /**
+               * Called after all children `onbeforesave` callbacks but before saving form values
+               * to model.  
+               * If at least one children callback returns `non-string` - it will not not be called.  
+               * See [editable-form demo](#editable-form) for details.
+               * 
+               * @var {method|attribute} onbeforesave
+               * @memberOf editable-form
+               * 
+               */
+              if(attrs.onbeforesave) {
+                eForm.$onbeforesave = function() {
+                  return $parse(attrs.onbeforesave)(scope, {$data: eForm.$data});
+                };
+              }
+
+              /**
+               * Called when form values are saved to model.  
+               * See [editable-form demo](#editable-form) for details.
+               * 
+               * @var {method|attribute} onaftersave 
+               * @memberOf editable-form
+               * 
+               */
+              if(attrs.onaftersave) {
+                eForm.$onaftersave = function() {
+                  return $parse(attrs.onaftersave)(scope, {$data: eForm.$data});
+                };
+              }
+
+              elem.bind('submit', function(event) {
+                event.preventDefault();
+                scope.$apply(function() {
+                  eForm.$submit();
+                });
+              });
+            }
+          }
+        };
+      }
+    };
+}]);
+/*
+Helpers
+*/
+
+/*
+Collect results of function calls. Shows waiting if there are promises. 
+Finally, applies callbacks if:
+- onTrue(): all results are true and all promises resolved to true
+- onFalse(): at least one result is false or promise resolved to false
+- onString(): at least one result is string or promise rejected or promise resolved to string
+*/
+angular.module('xeditable').factory('editablePromiseCollection', ['$q', function($q) { 
+
+  function promiseCollection() {
+    return {
+      promises: [],
+      hasFalse: false,
+      hasString: false,
+      when: function(result, noPromise) {
+        if (result === false) {
+          this.hasFalse = true;
+        } else if (!noPromise && angular.isObject(result)) {
+          this.promises.push($q.when(result));
+        } else if (angular.isString(result)){
+          this.hasString = true;
+        } else { //result === true || result === undefined || result === null
+          return;
+        }
+      },
+      //callbacks: onTrue, onFalse, onString
+      then: function(callbacks) {
+        callbacks = callbacks || {};
+        var onTrue = callbacks.onTrue || angular.noop;
+        var onFalse = callbacks.onFalse || angular.noop;
+        var onString = callbacks.onString || angular.noop;
+        var onWait = callbacks.onWait || angular.noop;
+
+        var self = this;
+
+        if (this.promises.length) {
+          onWait(true);
+          $q.all(this.promises).then(
+            //all resolved       
+            function(results) {
+              onWait(false);
+              //check all results via same `when` method (without checking promises)
+              angular.forEach(results, function(result) {
+                self.when(result, true);  
+              });
+              applyCallback();
+            },
+            //some rejected
+            function(error) { 
+              onWait(false);
+              onString();
+            }
+          );
+        } else {
+          applyCallback();
+        }
+
+        function applyCallback() {
+          if (!self.hasString && !self.hasFalse) {
+            onTrue();
+          } else if (!self.hasString && self.hasFalse) {
+            onFalse();
+          } else {
+            onString();
+          }
+        }
+
+      }
+    };
+  }
+
+  return promiseCollection;
+
+}]);
+
+angular.module('xeditable').factory('editableUtils', [function() {
+  return {
+    indexOf: function (array, obj) {
+      if (array.indexOf) return array.indexOf(obj);
+
+      for ( var i = 0; i < array.length; i++) {
+        if (obj === array[i]) return i;
+      }
+      return -1;
+    },
+
+    arrayRemove: function (array, value) {
+      var index = this.indexOf(array, value);
+      if (index >= 0) {
+        array.splice(index, 1);
+      }
+      return value;
+    },
+
+    // copy from https://github.com/angular/angular.js/blob/master/src/Angular.js
+    camelToDash: function(str) {
+      var SNAKE_CASE_REGEXP = /[A-Z]/g;
+      return str.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
+        return (pos ? '-' : '') + letter.toLowerCase();
+      });
+    },
+
+    dashToCamel: function(str) {
+      var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
+      var MOZ_HACK_REGEXP = /^moz([A-Z])/;
+      return str.
+        replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
+          return offset ? letter.toUpperCase() : letter;
+        }).
+        replace(MOZ_HACK_REGEXP, 'Moz$1');
+    }
+  };
+}]);
+
+/*
+Editable themes:
+- default
+- bootstrap 2
+- bootstrap 3
+
+Note: in postrender() `this` is instance of editableController
+*/
+angular.module('xeditable').factory('editableThemes', function() {
+  var themes = {
+    //default
+    'default': {
+      formTpl:      '<form class="editable-wrap"></form>',
+      noformTpl:    '<span class="editable-wrap"></span>',
+      controlsTpl:  '<span class="editable-controls"></span>',
+      inputTpl:     '',
+      errorTpl:     '<div class="editable-error" ng-show="$error">{{$error}}</div>',
+      buttonsTpl:   '<span class="editable-buttons"></span>',
+      submitTpl:    '<button type="submit">save</button>',
+      cancelTpl:    '<button type="button" ng-click="$form.$cancel()">cancel</button>'
+    },
+
+    //bs2
+    'bs2': {
+      formTpl:     '<form class="form-inline editable-wrap" role="form"></form>',
+      noformTpl:   '<span class="editable-wrap"></span>',
+      controlsTpl: '<div class="editable-controls controls control-group" ng-class="{\'error\': $error}"></div>',
+      inputTpl:    '',
+      errorTpl:    '<div class="editable-error help-block" ng-show="$error">{{$error}}</div>',
+      buttonsTpl:  '<span class="editable-buttons"></span>',
+      submitTpl:   '<button type="submit" class="btn btn-primary"><span class="icon-ok icon-white"></span></button>',
+      cancelTpl:   '<button type="button" class="btn" ng-click="$form.$cancel()">'+
+                      '<span class="icon-remove"></span>'+
+                   '</button>'
+
+    },
+
+    //bs3
+    'bs3': {
+      formTpl:     '<form class="form-inline editable-wrap" role="form"></form>',
+      noformTpl:   '<span class="editable-wrap"></span>',
+      controlsTpl: '<div class="editable-controls form-group" ng-class="{\'has-error\': $error}"></div>',
+      inputTpl:    '',
+      errorTpl:    '<div class="editable-error help-block" ng-show="$error">{{$error}}</div>',
+      buttonsTpl:  '<span class="editable-buttons"></span>',
+      submitTpl:   '<button type="submit" class="btn btn-primary"><span class="glyphicon glyphicon-ok"></span></button>',
+      cancelTpl:   '<button type="button" class="btn btn-default" ng-click="$form.$cancel()">'+
+                     '<span class="glyphicon glyphicon-remove"></span>'+
+                   '</button>',
+
+      //bs3 specific prop to change buttons class: btn-sm, btn-lg
+      buttonsClass: '',
+      //bs3 specific prop to change standard inputs class: input-sm, input-lg
+      inputClass: '',
+      postrender: function() {
+        //apply `form-control` class to std inputs
+        switch(this.directiveName) {
+          case 'editableText':
+          case 'editableSelect':
+          case 'editableTextarea':
+            this.inputEl.addClass('form-control');
+            if(this.theme.inputClass) {
+              // don`t apply `input-sm` and `input-lg` to select multiple
+              // should be fixed in bs itself!
+              if(this.inputEl.attr('multiple') &&
+                (this.theme.inputClass === 'input-sm' || this.theme.inputClass === 'input-lg')) {
+                  break;
+              }
+              this.inputEl.addClass(this.theme.inputClass);
+            }
+          break;
+        }
+
+        //apply buttonsClass (bs3 specific!)
+        if(this.buttonsEl && this.theme.buttonsClass) {
+          this.buttonsEl.find('button').addClass(this.theme.buttonsClass);
+        }
+      }
+    }
+  };
+
+  return themes;
+});
\ No newline at end of file
diff --git src/main/webapp/js/lib/angular-xeditable.min.js src/main/webapp/js/lib/angular-xeditable.min.js
new file mode 100644
index 0000000..b48cd49
--- /dev/null
+++ src/main/webapp/js/lib/angular-xeditable.min.js
@@ -0,0 +1,6 @@
+/*!
+angular-xeditable - 0.1.7
+Edit-in-place for angular.js
+Build date: 2013-10-26 
+*/
+angular.module("xeditable",[]).value("editableOptions",{theme:"default",buttons:"right",blur:"cancel"}),angular.module("xeditable").directive("editableBsdate",["editableDirectiveFactory",function(a){return a({directiveName:"editableBsdate",inputTpl:'<input type="text">'})}]),angular.module("xeditable").directive("editableBstime",["editableDirectiveFactory",function(a){return a({directiveName:"editableBstime",inputTpl:"<timepicker></timepicker>",render:function(){this.parent.render.call(this);var a=angular.element('<div class="well well-small" style="display:inline-block;"></div>');a.attr("ng-model",this.inputEl.attr("ng-model")),this.inputEl.removeAttr("ng-model"),this.attrs.eNgChange&&(a.attr("ng-change",this.inputEl.attr("ng-change")),this.inputEl.removeAttr("ng-change")),this.inputEl.wrap(a)}})}]),angular.module("xeditable").directive("editableCheckbox",["editableDirectiveFactory",function(a){return a({directiveName:"editableCheckbox",inputTpl:'<input type="checkbox">',render:function(){this.parent.render.call(this),this.attrs.eTitle&&(this.inputEl.wrap("<label></label>"),this.inputEl.after(angular.element("<span></span>").text(" "+this.attrs.eTitle)))},autosubmit:function(){var a=this;a.inputEl.bind("change",function(){setTimeout(function(){a.scope.$apply(function(){a.scope.$form.$submit()})},500)})}})}]),function(){var a="text|email|tel|number|url|search|color|date|datetime|time|month|week".split("|");angular.forEach(a,function(a){var b="editable"+a.charAt(0).toUpperCase()+a.slice(1);angular.module("xeditable").directive(b,["editableDirectiveFactory",function(c){return c({directiveName:b,inputTpl:'<input type="'+a+'">'})}])}),angular.module("xeditable").directive("editableRange",["editableDirectiveFactory",function(a){return a({directiveName:"editableRange",inputTpl:'<input type="range" id="range" name="range">',render:function(){this.parent.render.call(this),this.inputEl.after("<output>{{$data}}</output>")}})}])}(),angular.module("xeditable").directive("editableSelect",["editableDirectiveFactory",function(a){return a({directiveName:"editableSelect",inputTpl:"<select></select>",autosubmit:function(){var a=this;a.inputEl.bind("change",function(){a.scope.$apply(function(){a.scope.$form.$submit()})})}})}]),angular.module("xeditable").directive("editableTextarea",["editableDirectiveFactory",function(a){return a({directiveName:"editableTextarea",inputTpl:"<textarea></textarea>",addListeners:function(){var a=this;a.parent.addListeners.call(a),a.single&&"no"!==a.buttons&&a.autosubmit()},autosubmit:function(){var a=this;a.inputEl.bind("keydown",function(b){(b.ctrlKey||b.metaKey)&&13===b.keyCode&&a.scope.$apply(function(){a.scope.$form.$submit()})})}})}]),angular.module("xeditable").factory("editableController",["$q","$document","editableUtils","$rootScope",function(a,b,c,d){function e(a,b,d,e,g,h,i,j,k){var l,m,n=this;n.scope=a,n.elem=d,n.attrs=b,n.inputEl=null,n.editorEl=null,n.single=!0,n.error="",n.theme=g[h.theme]||g["default"],n.parent={},n.clicked=!1,n.inputTpl="",n.directiveName="",n.single=null,n.buttons="right",n.blur="ignore",n.init=function(c){if(n.single=c,n.name=b.eName||b[n.directiveName],!b[n.directiveName])throw"You should provide value for `"+n.directiveName+"` in editable element!";l=e(b[n.directiveName]),n.single?(n.buttons=n.attrs.buttons||h.buttons,n.blur=n.attrs.blur||("no"===n.buttons?"cancel":h.blur)):(n.buttons="no",n.blur="ignore"),b.eName&&n.scope.$watch("$data",function(a){n.scope.$form.$data[b.eName]=a}),b.onshow&&(n.onshow=function(){return n.catchError(e(b.onshow)(a))}),b.onhide&&(n.onhide=function(){return e(b.onhide)(a)}),b.oncancel&&(n.oncancel=function(){return e(b.oncancel)(a)}),b.onbeforesave&&(n.onbeforesave=function(){return n.catchError(e(b.onbeforesave)(a))}),b.onaftersave&&(n.onaftersave=function(){return n.catchError(e(b.onaftersave)(a))}),a.$parent.$watch(b[n.directiveName],function(){n.handleEmpty()})},n.render=function(){var a=n.theme;n.inputEl=angular.element(n.inputTpl),n.controlsEl=angular.element(a.controlsTpl),n.controlsEl.append(n.inputEl),"no"!==n.buttons&&(n.buttonsEl=angular.element(a.buttonsTpl),n.submitEl=angular.element(a.submitTpl),n.cancelEl=angular.element(a.cancelTpl),n.buttonsEl.append(n.submitEl).append(n.cancelEl),n.controlsEl.append(n.buttonsEl),n.inputEl.addClass("editable-has-buttons")),n.errorEl=angular.element(a.errorTpl),n.controlsEl.append(n.errorEl),n.editorEl=angular.element(n.single?a.formTpl:a.noformTpl),n.editorEl.append(n.controlsEl);for(var d in b.$attr)if(!(d.length<=1)){var e=!1,f=d.substring(1,2);if("e"===d.substring(0,1)&&f===f.toUpperCase()&&(e=d.substring(1),"Form"!==e&&"NgSubmit"!==e)){e=e.substring(0,1).toLowerCase()+c.camelToDash(e.substring(1));var g=""===b[d]?e:b[d];n.inputEl.attr(e,g)}}n.inputEl.addClass("editable-input"),n.inputEl.attr("ng-model","$data"),n.editorEl.addClass(c.camelToDash(n.directiveName)),n.single&&n.editorEl.attr("editable-form","$form"),angular.isFunction(a.postrender)&&a.postrender.call(n)},n.show=function(){return n.scope.$data=l(a.$parent),n.render(),d.after(n.editorEl),j(n.editorEl)(a),n.addListeners(),d.addClass("editable-hide"),setTimeout(function(){-1===c.indexOf(f,n)&&f.push(n)},0),n.onshow()},n.hide=function(){return n.editorEl.remove(),d.removeClass("editable-hide"),c.arrayRemove(f,n),n.onhide()},n.cancel=function(){n.oncancel()},n.addListeners=function(){n.inputEl.bind("keyup",function(a){if(n.single)switch(a.keyCode){case 27:n.scope.$form.$cancel()}}),n.single&&"no"===n.buttons&&n.autosubmit(),n.editorEl.bind("click",function(a){1===a.which&&(n.clicked=!0)})},n.setWaiting=function(a){a?(m=!n.inputEl.attr("disabled")&&!n.inputEl.attr("ng-disabled")&&!n.inputEl.attr("ng-enabled"),m&&(n.inputEl.attr("disabled","disabled"),n.buttonsEl&&n.buttonsEl.find("button").attr("disabled","disabled"))):m&&(n.inputEl.removeAttr("disabled"),n.buttonsEl&&n.buttonsEl.find("button").removeAttr("disabled"))},n.activate=function(){setTimeout(function(){n.inputEl[0].focus()},0)},n.setError=function(b){angular.isObject(b)||(a.$error=b,n.error=b)},n.catchError=function(a,b){return angular.isObject(a)&&b!==!0?k.when(a).then(angular.bind(this,function(a){this.catchError(a,!0)}),angular.bind(this,function(a){this.catchError(a,!0)})):b&&angular.isObject(a)&&a.status&&200!==a.status&&a.data&&angular.isString(a.data)?(this.setError(a.data),a=a.data):angular.isString(a)&&this.setError(a),a},n.save=function(){l.assign(a.$parent,angular.copy(n.scope.$data))},n.handleEmpty=function(){var b=l(a.$parent),c=null===b||void 0===b||""===b||angular.isArray(b)&&0===b.length;d.toggleClass("editable-empty",c)},n.autosubmit=angular.noop,n.onshow=angular.noop,n.onhide=angular.noop,n.oncancel=angular.noop,n.onbeforesave=angular.noop,n.onaftersave=angular.noop}var f=[];return b.bind("click",function(a){if(1===a.which){for(var b=[],c=[],e=0;e<f.length;e++)f[e].clicked?f[e].clicked=!1:("cancel"===f[e].blur&&b.push(f[e]),"submit"===f[e].blur&&c.push(f[e]));(b.length||c.length)&&d.$apply(function(){angular.forEach(b,function(a){a.scope.$form.$hide()}),angular.forEach(c,function(a){a.scope.$form.$submit()})})}}),e.$inject=["$scope","$attrs","$element","$parse","editableThemes","editableOptions","$rootScope","$compile","$q"],e}]),angular.module("xeditable").factory("editableDirectiveFactory",["$parse","$compile","editableThemes","$rootScope","$document","editableController","editableFormController",function(a,b,c,d,e,f,g){return function(b){return{restrict:"A",scope:!0,require:[b.directiveName,"?^form"],controller:f,link:function(c,f,h,i){var j,k=i[0],l=!1;if(i[1])j=i[1],l=!0;else if(h.eForm){var m=a(h.eForm)(c);if(m)j=m,l=!0;else for(var n=0;n<e[0].forms.length;n++)if(e[0].forms[n].name===h.eForm){j=null,l=!0;break}}if(angular.forEach(b,function(a,b){void 0!==k[b]&&(k.parent[b]=k[b])}),angular.extend(k,b),k.init(!l),c.$editable=k,f.addClass("editable"),l)if(j){if(c.$form=j,!c.$form.$addEditable)throw"Form with editable elements should have `editable-form` attribute.";c.$form.$addEditable(k)}else d.$$editableBuffer=d.$$editableBuffer||{},d.$$editableBuffer[h.eForm]=d.$$editableBuffer[h.eForm]||[],d.$$editableBuffer[h.eForm].push(k),c.$form=null;else c.$form=g(),c.$form.$addEditable(k),h.eForm&&(c.$parent[h.eForm]=c.$form),h.eForm||(f.addClass("editable-click"),f.bind("click",function(a){a.preventDefault(),a.editable=k,c.$apply(function(){c.$form.$show()})}))}}}}]),angular.module("xeditable").factory("editableFormController",["$parse","editablePromiseCollection",function(a,b){var c={$addEditable:function(a){this.$editables.push(a),a.elem.bind("$destroy",angular.bind(this,this.$removeEditable,a)),a.scope.$form||(a.scope.$form=this),this.$visible&&a.catchError(a.show())},$removeEditable:function(a){for(var b=0;b<this.$editables.length;b++)if(this.$editables[b]===a)return this.$editables.splice(b,1),void 0},$show:function(){if(!this.$visible){this.$visible=!0;var a=b();a.when(this.$onshow()),this.$setError(null,""),angular.forEach(this.$editables,function(b){a.when(b.show())}),a.then({onWait:angular.bind(this,this.$setWaiting),onTrue:angular.bind(this,this.$activate),onFalse:angular.bind(this,this.$activate),onString:angular.bind(this,this.$activate)})}},$activate:function(a){var b;if(this.$editables.length){if(angular.isString(a))for(b=0;b<this.$editables.length;b++)if(this.$editables[b].name===a)return this.$editables[b].activate(),void 0;for(b=0;b<this.$editables.length;b++)if(this.$editables[b].error)return this.$editables[b].activate(),void 0;this.$editables[0].activate()}},$hide:function(){this.$visible&&(this.$visible=!1,this.$onhide(),angular.forEach(this.$editables,function(a){a.hide()}))},$cancel:function(){this.$visible&&(this.$oncancel(),angular.forEach(this.$editables,function(a){a.cancel()}),this.$hide())},$setWaiting:function(a){this.$waiting=!!a,angular.forEach(this.$editables,function(b){b.setWaiting(!!a)})},$setError:function(a,b){angular.forEach(this.$editables,function(c){a&&c.name!==a||c.setError(b)})},$submit:function(){function a(a){var c=b();c.when(this.$onbeforesave()),c.then({onWait:angular.bind(this,this.$setWaiting),onTrue:a?angular.bind(this,this.$save):angular.bind(this,this.$hide),onFalse:angular.bind(this,this.$hide),onString:angular.bind(this,this.$activate)})}if(!this.$waiting){this.$setError(null,"");var c=b();angular.forEach(this.$editables,function(a){c.when(a.onbeforesave())}),c.then({onWait:angular.bind(this,this.$setWaiting),onTrue:angular.bind(this,a,!0),onFalse:angular.bind(this,a,!1),onString:angular.bind(this,this.$activate)})}},$save:function(){angular.forEach(this.$editables,function(a){a.save()});var a=b();a.when(this.$onaftersave()),angular.forEach(this.$editables,function(b){a.when(b.onaftersave())}),a.then({onWait:angular.bind(this,this.$setWaiting),onTrue:angular.bind(this,this.$hide),onFalse:angular.bind(this,this.$hide),onString:angular.bind(this,this.$activate)})},$onshow:angular.noop,$oncancel:angular.noop,$onhide:angular.noop,$onbeforesave:angular.noop,$onaftersave:angular.noop};return function(){return angular.extend({$editables:[],$visible:!1,$waiting:!1,$data:{}},c)}}]),angular.module("xeditable").directive("editableForm",["$rootScope","$parse","editableFormController",function(a,b,c){return{restrict:"A",require:["form"],compile:function(){return{pre:function(b,d,e,f){var g,h=f[0];e.editableForm?b[e.editableForm]&&b[e.editableForm].$show?(g=b[e.editableForm],angular.extend(h,g)):(g=c(),b[e.editableForm]=g,angular.extend(g,h)):(g=c(),angular.extend(h,g));var i=a.$$editableBuffer,j=h.$name;j&&i&&i[j]&&(angular.forEach(i[j],function(a){g.$addEditable(a)}),delete i[j])},post:function(a,c,d,e){var f;f=d.editableForm&&a[d.editableForm]&&a[d.editableForm].$show?a[d.editableForm]:e[0],d.onshow&&(f.$onshow=angular.bind(f,b(d.onshow),a)),d.onhide&&(f.$onhide=angular.bind(f,b(d.onhide),a)),d.oncancel&&(f.$oncancel=angular.bind(f,b(d.oncancel),a)),d.shown&&b(d.shown)(a)&&f.$show(),d.ngSubmit||d.submit||(d.onbeforesave&&(f.$onbeforesave=function(){return b(d.onbeforesave)(a,{$data:f.$data})}),d.onaftersave&&(f.$onaftersave=function(){return b(d.onaftersave)(a,{$data:f.$data})}),c.bind("submit",function(b){b.preventDefault(),a.$apply(function(){f.$submit()})}))}}}}}]),angular.module("xeditable").factory("editablePromiseCollection",["$q",function(a){function b(){return{promises:[],hasFalse:!1,hasString:!1,when:function(b,c){if(b===!1)this.hasFalse=!0;else if(!c&&angular.isObject(b))this.promises.push(a.when(b));else{if(!angular.isString(b))return;this.hasString=!0}},then:function(b){function c(){h.hasString||h.hasFalse?!h.hasString&&h.hasFalse?e():f():d()}b=b||{};var d=b.onTrue||angular.noop,e=b.onFalse||angular.noop,f=b.onString||angular.noop,g=b.onWait||angular.noop,h=this;this.promises.length?(g(!0),a.all(this.promises).then(function(a){g(!1),angular.forEach(a,function(a){h.when(a,!0)}),c()},function(){g(!1),f()})):c()}}}return b}]),angular.module("xeditable").factory("editableUtils",[function(){return{indexOf:function(a,b){if(a.indexOf)return a.indexOf(b);for(var c=0;c<a.length;c++)if(b===a[c])return c;return-1},arrayRemove:function(a,b){var c=this.indexOf(a,b);return c>=0&&a.splice(c,1),b},camelToDash:function(a){var b=/[A-Z]/g;return a.replace(b,function(a,b){return(b?"-":"")+a.toLowerCase()})},dashToCamel:function(a){var b=/([\:\-\_]+(.))/g,c=/^moz([A-Z])/;return a.replace(b,function(a,b,c,d){return d?c.toUpperCase():c}).replace(c,"Moz$1")}}}]),angular.module("xeditable").factory("editableThemes",function(){var a={"default":{formTpl:'<form class="editable-wrap"></form>',noformTpl:'<span class="editable-wrap"></span>',controlsTpl:'<span class="editable-controls"></span>',inputTpl:"",errorTpl:'<div class="editable-error" ng-show="$error">{{$error}}</div>',buttonsTpl:'<span class="editable-buttons"></span>',submitTpl:'<button type="submit">save</button>',cancelTpl:'<button type="button" ng-click="$form.$cancel()">cancel</button>'},bs2:{formTpl:'<form class="form-inline editable-wrap" role="form"></form>',noformTpl:'<span class="editable-wrap"></span>',controlsTpl:'<div class="editable-controls controls control-group" ng-class="{\'error\': $error}"></div>',inputTpl:"",errorTpl:'<div class="editable-error help-block" ng-show="$error">{{$error}}</div>',buttonsTpl:'<span class="editable-buttons"></span>',submitTpl:'<button type="submit" class="btn btn-primary"><span class="icon-ok icon-white"></span></button>',cancelTpl:'<button type="button" class="btn" ng-click="$form.$cancel()"><span class="icon-remove"></span></button>'},bs3:{formTpl:'<form class="form-inline editable-wrap" role="form"></form>',noformTpl:'<span class="editable-wrap"></span>',controlsTpl:'<div class="editable-controls form-group" ng-class="{\'has-error\': $error}"></div>',inputTpl:"",errorTpl:'<div class="editable-error help-block" ng-show="$error">{{$error}}</div>',buttonsTpl:'<span class="editable-buttons"></span>',submitTpl:'<button type="submit" class="btn btn-primary"><span class="glyphicon glyphicon-ok"></span></button>',cancelTpl:'<button type="button" class="btn btn-default" ng-click="$form.$cancel()"><span class="glyphicon glyphicon-remove"></span></button>',buttonsClass:"",inputClass:"",postrender:function(){switch(this.directiveName){case"editableText":case"editableSelect":case"editableTextarea":if(this.inputEl.addClass("form-control"),this.theme.inputClass){if(this.inputEl.attr("multiple")&&("input-sm"===this.theme.inputClass||"input-lg"===this.theme.inputClass))break;this.inputEl.addClass(this.theme.inputClass)}}this.buttonsEl&&this.theme.buttonsClass&&this.buttonsEl.find("button").addClass(this.theme.buttonsClass)}}};return a});
\ No newline at end of file
diff --git src/main/webapp/js/modules.js src/main/webapp/js/modules.js
index 4e688f7..002ca4b 100644
--- src/main/webapp/js/modules.js
+++ src/main/webapp/js/modules.js
@@ -1,15 +1,19 @@
-var application = angular.module('airplay', [ 'ui.bootstrap', 'ui.sortable', 'airplay.commons' ]).config(function($routeProvider) {
+var application = angular.module('airplay', [ 'ui.bootstrap', 'ui.sortable', 'xeditable', 'airplay.commons' ]).config(function($routeProvider) {
 	$routeProvider.when('/charts', {
 		templateUrl : '/airplay-web/views/charts/listTemplate.html',
 		controller : 'ChartListController'
 	}).when('/songs', {
 		templateUrl : '/airplay-web/views/songs/listTemplate.html',
 		controller : 'SongListController'
 	});
 });
 
+application.run(function(editableOptions, editableThemes) {
+	editableOptions.theme = 'bs2';
+});
+
 application.factory('ChartService', [ 'RemoteService', function(RemoteService) {
 	var ChartService = {
 		charts : RemoteService.using('/charts'),
 		chartStates : RemoteService.using('/charts/:identifier/:date')
 	};
diff --git src/main/webapp/views/songs/inlinerow.html src/main/webapp/views/songs/inlinerow.html
new file mode 100644
index 0000000..9c9b6f3
--- /dev/null
+++ src/main/webapp/views/songs/inlinerow.html
@@ -0,0 +1,33 @@
+<div ng-controller="EditableRowCtrl">
+	<table class="table table-bordered table-hover table-condensed">
+		<tr style="font-weight: bold">
+			<td style="width: 35%">Name</td>
+			<td style="width: 20%">Status</td>
+			<td style="width: 20%">Group</td>
+			<td style="width: 25%">Edit</td>
+		</tr>
+		<tr ng-repeat="user in users">
+			<td>
+				<!-- editable username (text with validation) --> <span editable-text="user.name" e-name="name" e-form="rowform" onbeforesave="checkName($data, user.id)" e-required> {{ user.name || 'empty' }} </span>
+			</td>
+			<td>
+				<!-- editable status (select-local) --> <span editable-select="user.status" e-name="status" e-form="rowform" e-ng-options="s.value as s.text for s in statuses"> {{ showStatus(user) }} </span>
+			</td>
+			<td>
+				<!-- editable group (select-remote) --> <span editable-select="user.group" e-name="group" onshow="loadGroups()" e-form="rowform" e-ng-options="g.id as g.text for g in groups"> {{ showGroup(user) }} </span>
+			</td>
+			<td style="white-space: nowrap">
+				<!-- form -->
+				<form editable-form name="rowform" onbeforesave="saveUser($data, user.id)" ng-show="rowform.$visible" class="form-buttons form-inline" shown="inserted == user">
+					<button type="submit" ng-disabled="rowform.$waiting" class="btn btn-primary">save</button>
+					<button type="button" ng-disabled="rowform.$waiting" ng-click="rowform.$cancel()" class="btn btn-default">cancel</button>
+				</form>
+				<div class="buttons" ng-show="!rowform.$visible">
+					<button class="btn btn-primary" ng-click="rowform.$show()">edit</button>
+					<button class="btn btn-danger" ng-click="removeUser($index)">del</button>
+				</div>
+			</td>
+		</tr>
+	</table>
+	<button class="btn btn-default" ng-click="addUser()">Add row</button>
+</div>
\ No newline at end of file
diff --git src/main/webapp/views/songs/inlinerow.js src/main/webapp/views/songs/inlinerow.js
new file mode 100644
index 0000000..e224f31
--- /dev/null
+++ src/main/webapp/views/songs/inlinerow.js
@@ -0,0 +1,92 @@
+app.controller('EditableRowCtrl', function($scope, $filter, $http) {
+	$scope.users = [ {
+		id : 1,
+		name : 'awesome user1',
+		status : 2,
+		group : 4,
+		groupName : 'admin'
+	}, {
+		id : 2,
+		name : 'awesome user2',
+		status : undefined,
+		group : 3,
+		groupName : 'vip'
+	}, {
+		id : 3,
+		name : 'awesome user3',
+		status : 2,
+		group : null
+	} ];
+
+	$scope.statuses = [ {
+		value : 1,
+		text : 'status1'
+	}, {
+		value : 2,
+		text : 'status2'
+	}, {
+		value : 3,
+		text : 'status3'
+	}, {
+		value : 4,
+		text : 'status4'
+	} ];
+
+	$scope.groups = [];
+	$scope.loadGroups = function() {
+		return $scope.groups.length ? null : $http.get('/groups').success(function(data) {
+			$scope.groups = data;
+		});
+	};
+
+	$scope.showGroup = function(user) {
+		if (user.group && $scope.groups.length) {
+			var selected = $filter('filter')($scope.groups, {
+				id : user.group
+			});
+			return selected.length ? selected[0].text : 'Not set';
+		} else {
+			return user.groupName || 'Not set';
+		}
+	};
+
+	$scope.showStatus = function(user) {
+		var selected = [];
+		if (user.status) {
+			selected = $filter('filter')($scope.statuses, {
+				value : user.status
+			});
+		}
+		return selected.length ? selected[0].text : 'Not set';
+	};
+
+	$scope.checkName = function(data, id) {
+		if (id === 2 && data !== 'awesome') {
+			return "Username 2 should be `awesome`";
+		}
+	};
+
+	$scope.saveUser = function(data, id) {
+		// $scope.user not updated yet
+		angular.extend(data, {
+			id : id
+		});
+		return $http.post('/saveUser', data);
+	};
+
+	// remove user
+	$scope.removeUser = function(index) {
+		$scope.users.splice(index, 1);
+	};
+
+	// add user
+	$scope.addUser = function() {
+		$scope.inserted = {
+			id : $scope.users.length + 1,
+			name : '',
+			status : null,
+			group : null
+		};
+		$scope.users.push($scope.inserted);
+	};
+});
\ No newline at end of file
diff --git src/main/webapp/views/songs/listTemplate.html src/main/webapp/views/songs/listTemplate.html
index d8ff06d..db9fa94 100644
--- src/main/webapp/views/songs/listTemplate.html
+++ src/main/webapp/views/songs/listTemplate.html
@@ -9,33 +9,45 @@
 </form>
 <div class="panel panel-default scrollable-bordered" ng-show="songs.length > 0">
 	<table class="table table-condensed table-hover table-striped">
 		<thead>
 			<tr>
-				<th>Artist</th>
-				<th>Title</th>
-				<th>Publisher</th>
-				<th>Company</th>
-				<th>Disc</th>
-				<th></th>
+				<th style="width: 30%">Artist</th>
+				<th style="width: 30%">Title</th>
+				<th style="width: 10%">Publisher</th>
+				<th style="width: 10%">Company</th>
+				<th style="width: 15%">Disc</th>
+				<th style="width: 5%"></th>
 			</tr>
 		</thead>
 		<tbody>
 			<tr ng-repeat="song in songs">
-				<td>{{song.artist.name}}</td>
-				<td>{{song.name}}</td>
-				<td>{{song.publisher.name}}</td>
-				<td>{{song.recordCompany.name}}</td>
-				<td>{{song.discIdentifier}}</td>
-				<td>
+				<td><span editable-text="song.artist" e-name="artist" e-form="form" e-class="input-medium" e-typeahead="artist as artist.name for artist in artists($viewValue)" e-required e-as-server-validated>{{ song.artist.name || '-' }}</span></td>
+				<td><span editable-text="song.name" e-name="name" e-form="form" e-class="input-medium" e-required e-as-server-validated>{{ song.name || '-' }}</span></td>
+				<td><span editable-text="song.publisher" e-name="publisher" e-form="form" e-class="input-small" e-typeahead="publisher as publisher.name for publisher in publishers($viewValue)" e-as-server-validated>{{ song.publisher.name || '-' }}</span></td>
+				<td><span editable-text="song.recordCompany" e-name="recordCompany" e-form="form" e-class="input-small" e-typeahead="recordCompany as recordCompany.name for recordCompany in recordCompanies($viewValue)" e-as-server-validated>{{song.recordCompany.name || '-' }}</span></td>
+				<td><span editable-text="song.discIdentifier" e-name="discIdentifier" e-form="form" e-class="input-medium" e-required>{{ song.discIdentifier || '-' }}</span></td>
+				<td style="white-space: nowrap">
 					<div class="pull-right">
-						<button class="btn btn-info btn-sm" ng-click="editItem(song)">
-							<i class="icon-edit icon-white" />
-						</button>
-						<button class="btn btn-danger btn-sm" ng-click="deleteItem(song)">
-							<i class="icon-remove icon-white" />
-						</button>
+						<form class="form-inline" ng-show="form.$visible" editable-form name="form" onbeforesave="saveItem($data, song.identifier)" shown="inserted == song">
+							<div class="form-buttons ">
+								<button class="btn btn-primary btn-sm" type="submit" ng-disabled="form.$waiting">
+									<i class="icon-ok icon-white"></i>
+								</button>
+								<button class="btn btn-sm" type="reset" ng-disabled="form.$waiting" ng-click="form.$cancel()">
+									<i class="icon-remove icon-white"></i>
+								</button>
+							</div>
+						</form>
+						<div class="buttons" ng-show="!form.$visible">
+							<button class="btn btn-info btn-sm" ng-click="form.$show()">
+								<i class="icon-edit icon-white"></i>
+							</button>
+							<button class="btn btn-danger btn-sm" ng-click="deleteItem(song)">
+								<i class="icon-remove icon-white"></i>
+							</button>
+						</div>
 					</div>
 				</td>
 			</tr>
 	</table>
 	</tbody>